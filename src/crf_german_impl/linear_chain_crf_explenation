----------------------------------------------------------------
----------------------------------------------------------------
VITERBI DECODING:

1) input_energy = self.activation(K.dot(X, self.kernel) + self.bias)
----------------------------------------------------------------
X.shape = (2, 5, 3) -> (batch_size, max_seq_len, embedding_dim)
X =
  [
       [
           [1, 2, 3],
           [4, 5, 6],
           [7, 8, 9],
           [10, 11, 12],
           [13, 14, 15]
       ]
       ,
       [
           [16, 17, 18],
           [19, 20, 21],
           [22, 23, 24],
           [25, 26, 27],
           [28, 29, 30]
       ]
   ]
-----------------------------------------------------------------
self.kernel.shape = (3, 4) -> (embedding_dim, n_tags)
self.kernel =
  [
     [ 1.  2.  3.  4.],
     [ 5.  6.  7.  8.],
     [ 9. 10. 11. 12.]
  ]
------------------------------------------------------------------
self.bias.shape = (4,) -> (n_tags)
self.bias =
     [1. 2. 3. 4.]
------------------------------------------------------------------
    K.dot(X, self.kernel).shape = (2, 5, 3) * (3,4) = (2, 5, 4)
    K.dot(X, self.kernel) =
    [
       [[ 38.  44.  50.  56.]
        [ 83.  98. 113. 128.]
        [128. 152. 176. 200.]
        [173. 206. 239. 272.]
        [218. 260. 302. 344.]]

       [[263. 314. 365. 416.]
        [308. 368. 428. 488.]
        [353. 422. 491. 560.]
        [398. 476. 554. 632.]
        [443. 530. 617. 704.]]
    ]
.....................................................................
1)input_energy = self.activation(K.dot(X, self.kernel) + self.bias) =
  (K.dot(X, self.kernel) + self.bias).shape = (2, 5, 4) + (4) = (2, 5, 4)
     =
    [
        [[ 39.  46.  53.  60.]
         [ 84. 100. 116. 132.]
         [129. 154. 179. 204.]
         [174. 208. 242. 276.]
         [219. 262. 305. 348.]]

         [[264. 316. 368. 420.]
          [309. 370. 431. 492.]
          [354. 424. 494. 564.]
          [399. 478. 557. 636.]
          [444. 532. 620. 708.]]
    ]
------------------------------------------------------------------------------
------------------------------------------------------------------------------
If boundary are used add these to input energy

2) input_energy = self.add_boundary_energy(input_energy, mask. self.left_boundary, self.right_boundary)
-----------------------------------------------------------------------------
Compute boundaries:

a)left_boundary.shape = (4,) = (n_tags)
  left_boundary =  [1. 2. 3. 4.]
  Expand shape of self.left_boundary
  from (4,) to (1, 1, 4)
  left_boundary = [[[1. 2. 3. 4.]]]

b)right_boundary.shape = (4,) = (n_tags)
  right_boundary = [1. 2. 3. 4.]
  Expand shape of self.right_boundary
  from (4,) to (1, 1, 4)
  rigth_boundary = [[[1. 2. 3. 4.]]]

Compute mask:

mask.shape = (2, 5) = (batch_size, max_seq_len)
mask =
    [
      [ True  True False  True False]
      [ False  True  True False  True]
    ]
a) Expand shape of mask
    from (2, 5) to (2, 5, 1)
    and convert bool type to float
    mask =  [
             [[1.],[1.],[0.],[1.],[0.]],
             [[0.],[1.],[1.],[0.],[1.]]
            ]
b) Define start_mask
    b1) shift mask to the right = shape(2, 5, 1)
        [
         [[0.],[1.],[1.],[0.],[1.]],
         [[0.],[0.],[1.],[1.],[0.]]
        ]
    b2) elementwise compare values (if mask[i] > shift_right_mask[i] then True else False)
        build bool tensor shape(2, 5, 1)
        [
         [[True],[False],[False],[True],[False]],
         [[False],[True],[False],[False],[True]]
        ]
    b3) convert bool tensor to float -> that is start_mask
        start_mask.shape = (2, 5, 1)
        start_mask =
        [
          [[1.],[0.],[0.],[1.],[0.]],
          [[0.],[1.],[0.],[0.],[1.]]
        ]
c) Define end_mask
    c1) shift mask to the left = shape(2, 5, 1)
        [
         [[1.],[0.],[1.],[0.],[0.]],
         [[1.],[1.],[0.],[1.],[0.]]
        ]
    c2) elementwise compare values (if shift_left_mask[i] > mask[i] then True else False)
         build bool tensor shape(2, 5, 1)
          [
            [[False],[False],[True],[False],[False]],
            [[True],[False],[False],[True],[False]]
          ]
    c3) convert bool tensor to float -> that is end_mask
          end_mask.shape(2, 5, 1)
          [
           [[0.],[0.],[1.],[0.],[0.]],
           [[1.],[0.],[0.],[1.],[0.]]
          ]
Bring together boundaries and masks:
a) input_energy = (input_energy + start_mask * left_boundary) + end_mask * right_boundary
   a1) start_mask * left_boundary = (2, 5, 1) *  (1, 1, 4) = (2, 5, 4)

start_mask([
             [[1.],[0.],[0.],[1.],[0.]],
             [[0.],[1.],[0.],[0.],[1.]]
         ])

         *
         lef_boundary
         ([[[1. 2. 3. 4.]]])
         =
         [
           [[1. 2. 3. 4.]
            [0. 0. 0. 0.]
            [0. 0. 0. 0.]
            [1. 2. 3. 4.]
            [0. 0. 0. 0.]]

           [[0. 0. 0. 0.]
            [1. 2. 3. 4.]
            [0. 0. 0. 0.]
            [0. 0. 0. 0.]
            [1. 2. 3. 4.]]
          ]
    a2) (input_energy + start_mask * left_boundary) = (2, 5, 4) + (2, 5, 4) = (2, 5, 4)

  input_energy([
                  [[ 39.  46.  53.  60.]
                   [ 84. 100. 116. 132.]
                   [129. 154. 179. 204.]
                   [174. 208. 242. 276.]
                   [219. 262. 305. 348.]]

                   [[264. 316. 368. 420.]
                    [309. 370. 431. 492.]
                    [354. 424. 494. 564.]
                    [399. 478. 557. 636.]
                    [444. 532. 620. 708.]]
              ])
              +
              ([
                 [[1. 2. 3. 4.]
                  [0. 0. 0. 0.]
                  [0. 0. 0. 0.]
                  [1. 2. 3. 4.]
                  [0. 0. 0. 0.]]

                 [[0. 0. 0. 0.]
                  [1. 2. 3. 4.]
                  [0. 0. 0. 0.]
                  [0. 0. 0. 0.]
                  [1. 2. 3. 4.]]
              ])
              =
               ([
                 [[ 40.  48.  56.  64.]
                  [ 84. 100. 116. 132.]
                  [129. 154. 179. 204.]
                  [175. 210. 245. 280.]
                  [219. 262. 305. 348.]]

                 [[264. 316. 368. 420.]
                  [310. 372. 434. 496.]
                  [354. 424. 494. 564.]
                  [399. 478. 557. 636.]
                  [445. 534. 623. 712.]]
                ])
      a3) end_mask * right_boundary = (2, 5, 1) * (1, 1, 4) = (2, 5, 4)
        end_mask([
                   [[0.],[0.],[1.],[0.],[0.]],
                   [[1.],[0.],[0.],[1.],[0.]]
                  ])
                  *
        right_boundary([
                        [[1. 2. 3. 4.]]
                       ])
                  =
                   ([
                      [[0. 0. 0. 0.]
                      [0. 0. 0. 0.]
                      [1. 2. 3. 4.]
                      [0. 0. 0. 0.]
                      [0. 0. 0. 0.]]

                     [[1. 2. 3. 4.]
                      [0. 0. 0. 0.]
                      [0. 0. 0. 0.]
                      [1. 2. 3. 4.]
                      [0. 0. 0. 0.]]
                   ])

2)input_energy = (input_energy + start_mask * left_boundary) + (end_mask * right_boundary) = (2, 5, 4)

(input_energy + start_mask * left_boundary)->
                          ([
                             [[ 40.  48.  56.  64.]
                              [ 84. 100. 116. 132.]
                              [129. 154. 179. 204.]
                              [175. 210. 245. 280.]
                              [219. 262. 305. 348.]]

                             [[264. 316. 368. 420.]
                              [310. 372. 434. 496.]
                              [354. 424. 494. 564.]
                              [399. 478. 557. 636.]
                              [445. 534. 623. 712.]]
                            ])

                              +
  (end_mask * right_boundary)([
                                [[0. 0. 0. 0.]
                                [0. 0. 0. 0.]
                                [1. 2. 3. 4.]
                                [0. 0. 0. 0.]
                                [0. 0. 0. 0.]]

                               [[1. 2. 3. 4.]
                                [0. 0. 0. 0.]
                                [0. 0. 0. 0.]
                                [1. 2. 3. 4.]
                                [0. 0. 0. 0.]]
                             ])
                             =
                            [
                             [[ 40.  48.  56.  64.]
                              [ 84. 100. 116. 132.]
                              [130. 156. 182. 208.]
                              [175. 210. 245. 280.]
                              [219. 262. 305. 348.]]

                             [[265. 318. 371. 424.]
                              [310. 372. 434. 496.]
                              [354. 424. 494. 564.]
                              [400. 480. 560. 640.]
                              [445. 534. 623. 712.]]
                            ]
2) input_energy = self.add_boundary_energy(input_energy, mask. self.left_boundary, self.right_boundary)=(2, 5, 4)=
                            [
                             [[ 40.  48.  56.  64.]
                              [ 84. 100. 116. 132.]
                              [130. 156. 182. 208.]
                              [175. 210. 245. 280.]
                              [219. 262. 305. 348.]]

                             [[265. 318. 371. 424.]
                              [310. 372. 434. 496.]
                              [354. 424. 494. 564.]
                              [400. 480. 560. 640.]
                              [445. 534. 623. 712.]]

---------------------------------------------------------------------------
---------------------------------------------------------------------------
3) Compute Forward Recursion for Viterbi:
    
