----------------------------------------------------------------
----------------------------------------------------------------
VITERBI DECODING:

1) input_energy = self.activation(K.dot(X, self.kernel) + self.bias)
----------------------------------------------------------------
X.shape = (2, 5, 3) -> (batch_size, max_seq_len, embedding_dim)
X =
  [
       [
           [1, 2, 3],
           [4, 5, 6],
           [7, 8, 9],
           [10, 11, 12],
           [13, 14, 15]
       ]
       ,
       [
           [16, 17, 18],
           [19, 20, 21],
           [22, 23, 24],
           [25, 26, 27],
           [28, 29, 30]
       ]
   ]
-----------------------------------------------------------------
self.kernel.shape = (3, 4) -> (embedding_dim, n_tags)
self.kernel =
  [
     [ 1.  2.  3.  4.],
     [ 5.  6.  7.  8.],
     [ 9. 10. 11. 12.]
  ]
------------------------------------------------------------------
self.bias.shape = (4,) -> (n_tags)
self.bias =
     [1. 2. 3. 4.]
------------------------------------------------------------------
    K.dot(X, self.kernel).shape = (2, 5, 3) * (3,4) = (2, 5, 4)
    K.dot(X, self.kernel) =
    [
       [[ 38.  44.  50.  56.]
        [ 83.  98. 113. 128.]
        [128. 152. 176. 200.]
        [173. 206. 239. 272.]
        [218. 260. 302. 344.]]

       [[263. 314. 365. 416.]
        [308. 368. 428. 488.]
        [353. 422. 491. 560.]
        [398. 476. 554. 632.]
        [443. 530. 617. 704.]]
    ]
.....................................................................
1)input_energy = self.activation(K.dot(X, self.kernel) + self.bias) =
  (K.dot(X, self.kernel) + self.bias).shape = (2, 5, 4) + (4) = (2, 5, 4)
     =
    [
        [[ 39.  46.  53.  60.]
         [ 84. 100. 116. 132.]
         [129. 154. 179. 204.]
         [174. 208. 242. 276.]
         [219. 262. 305. 348.]]

         [[264. 316. 368. 420.]
          [309. 370. 431. 492.]
          [354. 424. 494. 564.]
          [399. 478. 557. 636.]
          [444. 532. 620. 708.]]
    ]
------------------------------------------------------------------------------
------------------------------------------------------------------------------
If boundary are used add these to input energy

2) input_energy = self.add_boundary_energy(input_energy, mask. self.left_boundary, self.right_boundary)
-----------------------------------------------------------------------------
Compute boundaries:

a)left_boundary.shape = (4,) = (n_tags)
  left_boundary =  [1. 2. 3. 4.]
  Expand shape of self.left_boundary
  from (4,) to (1, 1, 4)
  left_boundary = [[[1. 2. 3. 4.]]]

b)right_boundary.shape = (4,) = (n_tags)
  right_boundary = [1. 2. 3. 4.]
  Expand shape of self.right_boundary
  from (4,) to (1, 1, 4)
  rigth_boundary = [[[1. 2. 3. 4.]]]

Compute mask:

mask.shape = (2, 5) = (batch_size, max_seq_len)
mask =
    [
      [ True  True False  True False]
      [ False  True  True False  True]
    ]
a) Expand shape of mask
    from (2, 5) to (2, 5, 1)
    and convert bool type to float
    mask =  [
             [[1.],[1.],[0.],[1.],[0.]],
             [[0.],[1.],[1.],[0.],[1.]]
            ]
b) Define start_mask
    b1) shift mask to the right = shape(2, 5, 1)
        [
         [[0.],[1.],[1.],[0.],[1.]],
         [[0.],[0.],[1.],[1.],[0.]]
        ]
    b2) elementwise compare values (if mask[i] > shift_right_mask[i] then True else False)
        build bool tensor shape(2, 5, 1)
        [
         [[True],[False],[False],[True],[False]],
         [[False],[True],[False],[False],[True]]
        ]
    b3) convert bool tensor to float -> that is start_mask
        start_mask.shape = (2, 5, 1)
        start_mask =
        [
          [[1.],[0.],[0.],[1.],[0.]],
          [[0.],[1.],[0.],[0.],[1.]]
        ]
c) Define end_mask
    c1) shift mask to the left = shape(2, 5, 1)
        [
         [[1.],[0.],[1.],[0.],[0.]],
         [[1.],[1.],[0.],[1.],[0.]]
        ]
    c2) elementwise compare values (if shift_left_mask[i] > mask[i] then True else False)
         build bool tensor shape(2, 5, 1)
          [
            [[False],[False],[True],[False],[False]],
            [[True],[False],[False],[True],[False]]
          ]
    c3) convert bool tensor to float -> that is end_mask
          end_mask.shape(2, 5, 1)
          [
           [[0.],[0.],[1.],[0.],[0.]],
           [[1.],[0.],[0.],[1.],[0.]]
          ]
Bring together boundaries and masks:
a) input_energy = (input_energy + start_mask * left_boundary) + end_mask * right_boundary
   a1) start_mask * left_boundary = (2, 5, 1) *  (1, 1, 4) = (2, 5, 4)

start_mask([
             [[1.],[0.],[0.],[1.],[0.]],
             [[0.],[1.],[0.],[0.],[1.]]
         ])

         *
         lef_boundary
         ([[[1. 2. 3. 4.]]])
         =
         [
           [[1. 2. 3. 4.]
            [0. 0. 0. 0.]
            [0. 0. 0. 0.]
            [1. 2. 3. 4.]
            [0. 0. 0. 0.]]

           [[0. 0. 0. 0.]
            [1. 2. 3. 4.]
            [0. 0. 0. 0.]
            [0. 0. 0. 0.]
            [1. 2. 3. 4.]]
          ]
    a2) (input_energy + start_mask * left_boundary) = (2, 5, 4) + (2, 5, 4) = (2, 5, 4)

  input_energy([
                  [[ 39.  46.  53.  60.]
                   [ 84. 100. 116. 132.]
                   [129. 154. 179. 204.]
                   [174. 208. 242. 276.]
                   [219. 262. 305. 348.]]

                   [[264. 316. 368. 420.]
                    [309. 370. 431. 492.]
                    [354. 424. 494. 564.]
                    [399. 478. 557. 636.]
                    [444. 532. 620. 708.]]
              ])
              +
              ([
                 [[1. 2. 3. 4.]
                  [0. 0. 0. 0.]
                  [0. 0. 0. 0.]
                  [1. 2. 3. 4.]
                  [0. 0. 0. 0.]]

                 [[0. 0. 0. 0.]
                  [1. 2. 3. 4.]
                  [0. 0. 0. 0.]
                  [0. 0. 0. 0.]
                  [1. 2. 3. 4.]]
              ])
              =
               ([
                 [[ 40.  48.  56.  64.]
                  [ 84. 100. 116. 132.]
                  [129. 154. 179. 204.]
                  [175. 210. 245. 280.]
                  [219. 262. 305. 348.]]

                 [[264. 316. 368. 420.]
                  [310. 372. 434. 496.]
                  [354. 424. 494. 564.]
                  [399. 478. 557. 636.]
                  [445. 534. 623. 712.]]
                ])
      a3) end_mask * right_boundary = (2, 5, 1) * (1, 1, 4) = (2, 5, 4)
        end_mask([
                   [[0.],[0.],[1.],[0.],[0.]],
                   [[1.],[0.],[0.],[1.],[0.]]
                  ])
                  *
        right_boundary([
                        [[1. 2. 3. 4.]]
                       ])
                  =
                   ([
                      [[0. 0. 0. 0.]
                      [0. 0. 0. 0.]
                      [1. 2. 3. 4.]
                      [0. 0. 0. 0.]
                      [0. 0. 0. 0.]]

                     [[1. 2. 3. 4.]
                      [0. 0. 0. 0.]
                      [0. 0. 0. 0.]
                      [1. 2. 3. 4.]
                      [0. 0. 0. 0.]]
                   ])

2)input_energy = (input_energy + start_mask * left_boundary) + (end_mask * right_boundary) = (2, 5, 4)

(input_energy + start_mask * left_boundary)->
                          ([
                             [[ 40.  48.  56.  64.]
                              [ 84. 100. 116. 132.]
                              [129. 154. 179. 204.]
                              [175. 210. 245. 280.]
                              [219. 262. 305. 348.]]

                             [[264. 316. 368. 420.]
                              [310. 372. 434. 496.]
                              [354. 424. 494. 564.]
                              [399. 478. 557. 636.]
                              [445. 534. 623. 712.]]
                            ])

                              +
  (end_mask * right_boundary)([
                                [[0. 0. 0. 0.]
                                [0. 0. 0. 0.]
                                [1. 2. 3. 4.]
                                [0. 0. 0. 0.]
                                [0. 0. 0. 0.]]

                               [[1. 2. 3. 4.]
                                [0. 0. 0. 0.]
                                [0. 0. 0. 0.]
                                [1. 2. 3. 4.]
                                [0. 0. 0. 0.]]
                             ])
                             =
                            [
                             [[ 40.  48.  56.  64.]
                              [ 84. 100. 116. 132.]
                              [130. 156. 182. 208.]
                              [175. 210. 245. 280.]
                              [219. 262. 305. 348.]]

                             [[265. 318. 371. 424.]
                              [310. 372. 434. 496.]
                              [354. 424. 494. 564.]
                              [400. 480. 560. 640.]
                              [445. 534. 623. 712.]]
                            ]
2) input_energy = self.add_boundary_energy(input_energy, mask. self.left_boundary, self.right_boundary)=(2, 5, 4)=
                            [
                             [[ 40.  48.  56.  64.]
                              [ 84. 100. 116. 132.]
                              [130. 156. 182. 208.]
                              [175. 210. 245. 280.]
                              [219. 262. 305. 348.]]

                             [[265. 318. 371. 424.]
                              [310. 372. 434. 496.]
                              [354. 424. 494. 564.]
                              [400. 480. 560. 640.]
                              [445. 534. 623. 712.]]

---------------------------------------------------------------------------
---------------------------------------------------------------------------
VITERBI FORWARD RECURSION:
3) argmin_tables = self.recursion(input_energy, mask)
Input parameters

     a) input_energy = shape(2, 5, 4)=
              [
                 [[ 40.  48.  56.  64.]
                  [ 84. 100. 116. 132.]
                  [130. 156. 182. 208.]
                  [175. 210. 245. 280.]
                  [219. 262. 305. 348.]]

                 [[265. 318. 371. 424.]
                  [310. 372. 434. 496.]
                  [354. 424. 494. 564.]
                  [400. 480. 560. 640.]
                  [445. 534. 623. 712.]]
               ]
    b) mask(predefined in init function) = shape(2, 5) =
            mask =
               [
                [ True  True False  True False]
                [False  True  True False  True]
               ]

------------------------------------------------------------------------------
For the computation we need to define recursion K.rnn:
    target_val_last, target_val_seq, _ = K.rnn(step_function(), input_energy, initial_states, constants)
For K.rnn we need to define step_function() with input parameters:
    def step(self, input_energy_t, states)

-------------------------------------------------------------------------------------------
3.1 Compute K.rnn:
   input_energy = shape(2, 5, 4)=
           [
              [[ 40.  48.  56.  64.]
               [ 84. 100. 116. 132.]
               [130. 156. 182. 208.]
               [175. 210. 245. 280.]
               [219. 262. 305. 348.]]

              [[265. 318. 371. 424.]
               [310. 372. 434. 496.]
               [354. 424. 494. 564.]
               [400. 480. 560. 640.]
               [445. 534. 623. 712.]]
            ]


3.1.1) Compute initial_states<list> = [prev_target_val, K.zeros_like(prev_target_val[:, :1])]
             initial_states<list> = [prev_target_val, take [0] element from second dimension of prev_target_val] =
             [<prev_target_val>, <[[0.],[0.]]>]

a) Compute prev_target_val = zeros_like(input_energy[:, 0, :]) -> take [0] element from second dimension
             shape from (2, 5, 4) to (2, 4)
             prev_target_val =
                     [
                      [ 40.  48.  56.  64.],
                      [265. 318. 371. 424.]
                     ]
                      into ->
                       [
                         [0. 0. 0. 0.],
                         [0. 0. 0. 0.]
                       ]
3.1.1) initial_states<list> = <shape(2, 5), sape(2,1)>
          [
           <[[0!., 0., 0., 0.],
            [0!., 0., 0., 0.]]>,

           <[[0!.],[0!.]]>
          ]

3.1.2) Compute constants = <list> = [chain_energy, mask_for_const]

a) Chain_energy (was predefined in init function); shape(4, 4)=(n_tags,n_tags)
         chain_energy =
                       [
                         [ 1.  2.  3.  4.]
                         [ 5.  6.  7.  8.]
                         [ 9. 10. 11. 12.]
                         [13. 14. 15. 16.]
                       ]

b) Expand_dims(chain_energy, 0)= from shape(4, 4) to (1, 4, 4)
                chain_energy = [
                                  [[ 1.  2.  3.  4.]
                                    [ 5.  6.  7.  8.]
                                    [ 9. 10. 11. 12.]
                                    [13. 14. 15. 16.]]
                               ]

b) Compute mask_for_const =  K.cast(K.concatenate([mask, K.zeros_like(mask[:, :1])], axis=1), floatx())


 mask.shape =  (2, 5)
                mask =
                   [
                    [ True  True False  True False]
                    [False  True  True False  True]
                   ]

         K.zeros_like(mask[:, :1])
                 mask[:, :1] = get [0] element from second dim = shape(2, 1) =
                              [[True], [False]]

         K.zeros_like(mask[:, :1]) for bool type will set all values to [False] -> shape(2,1) =
                      [[False],[False]]

         K.concatenate([mask, K.zeros_like(mask[:, :1])], axis=1 ) = K.concatenate([shape(2, 5), shape(2, 1)], axis=1) = shape(2, 6)
                  K.concatenate =
                  [
                   [ True  True False  True False False]
                   [False  True  True False  True False]
                  ]

        K.cast(K.concatenate(...), floatx()) convert bool to float = shape(2, 6)=
                  [
                    [1. 1. 0. 1. 0. 0.]
                    [0. 1. 1. 0. 1. 0.]
                  ]

b) mask_for_const = shape(2, 6) =
               [
                 [1. 1. 0. 1. 0. 0.]
                 [0. 1. 1. 0. 1. 0.]
               ]

3.1.2) constants<list> = [chain_energy, mask_for_const] = [shape(1, 4, 4), shape(2, 6)] =
                    [  <[[[ 1.,  2.,  3.,  4.],
                        [ 5.,  6.,  7.,  8.],
                        [ 9., 10., 11., 12.],
                        [13., 14., 15., 16.]]]>,

                        <[[1., 1., 0., 1., 0., 0.],
                         [0., 1., 1., 0., 1., 0.]]> ]
------------------------------------------------------------------------------------------
Computed parameters for K.rnn(step_function(), input_energy, initial_states, constants):

a) input_energy = shape(2, 5, 4)=
               [
                  [[ 40.  48.  56.  64.]
                   [ 84. 100. 116. 132.]
                   [130. 156. 182. 208.]
                   [175. 210. 245. 280.]
                   [219. 262. 305. 348.]]

                  [[265. 318. 371. 424.]
                   [310. 372. 434. 496.]
                   [354. 424. 494. 564.]
                   [400. 480. 560. 640.]
                   [445. 534. 623. 712.]]
                ]

b) initial_states<list> = [prev_target_val, K.zeros_like(prev_target_val[:, :1])]  = [shape(2, 4), shape[2, 1]]
                            /  where prev_target_val = K.zeros_like(input_energy[:, 0, :]) /
                             [K.zeros_like(input_energy[:, 0, :]), K.zeros_like(prev_target_val[:, :1]] =
                             [K.zeros_like(input_energy[:, 0, :]), K.zeros_like(prev_target_val[:, 0]] =

                          [ <[
                               [[0., 0., 0., 0.],
                                [0., 0., 0., 0.]
                             ]>,

                            <[[0.],[0.]]> ]

c) constants<list> = [chain_energy, mask_for_const] = [shape(1, 4, 4), shape(2, 6)] =
                  / where mask_for_const = K.cast(K.concatenate([mask, K.zeros_like(mask[:, 0])], axis=1), floatx()) ->
                  mask_for_const = from shape(2, 5) to (2, 6) /

      constants =    [
                      <[[[ 1.,  2.,  3.,  4.],
                        [ 5.,  6.,  7.,  8.],
                        [ 9., 10., 11., 12.],
                        [13., 14., 15., 16.]]]>,

                        <[[1., 1., 0., 1., 0., 0.],
                         [0., 1., 1., 0., 1., 0.]]>
                     ]
------------------------------------------------------------------------------------
3.2) Compute step_function(input_energy_t, states):
  Input parameters:
    a) input_energy_t = shape(2, 4) = take element input_energy(:, 0, :)
                   [
                     [ 40.  48.  56.  64.]
                     [265. 318. 371. 424.]
                   ]

    b) states<list> = [<initial_states>, <constants>]
       states<list> = [<shape(2, 4), shape[2, 1]>, <shape(1, 4, 4), shape(2, 6)>] =
       states<list> = [<prev_target_val, K.zeros_like(prev_target_val[:, 0])>, <chain_energy, mask_for_const>]
       states<list> =
                  [
                     <[[0!., 0., 0., 0.],
                        [0!., 0., 0., 0.]]>,

                      <[[0!.],[0!.]]>,

                      <[[[ 1.,  2.,  3.,  4.],
                          [ 5.,  6.,  7.,  8.],
                          [ 9., 10., 11., 12.],
                          [13., 14., 15., 16.]]]>,

                      <[[1., 1., 0., 1., 0., 0.],
                        [0., 1., 1., 0., 1., 0.]]>
                    ]

----------------------------------------------
Iteration 1:
prev_target_val, i, chain_energy = states[:3] -> take these elements from the states<list>

a) prev_target_val = shape(2,4) =
     [[0!!., 0., 0., 0.],
       [0!., 0., 0., 0.]]

b) i = shape(2,1) = K.zeros_like(prev_target_val[:, 0])
     [[0!!.],[0!.]]

c) chain_energy = shape(1, 4, 4) =
      [[[ 1.,  2.,  3.,  4.],
        [ 5.,  6.,  7.,  8.],
        [ 9., 10., 11., 12.],
        [13., 14., 15., 16.]]]

 d) t = K.cast(i[0, 0])
    t = [0!!]

 e) m = K.slice(states[3], [0, t], [-1, 2])

 e1) states[3] =  mask_for_const = shape(2, 6)

      <[[1.!, 1.!, 0., 1., 0., 0.],
        [0.!, 1.!, 1., 0., 1., 0.]]>


 e) m = K.slice(...) = take elem[0,0], elem[0,1], [1,0], [1,1] = shape(2,2) =

      [
       [1.!, 1.!],
       [0.!, 1.!]
      ]

 f) input_energy_t = input_energy_t * K.expand_dims(m[:, 0]) -> (E(y|x)=y1 * x1))

f1) m[:, 0] = [1.!, 0.!]  shape(2)->  expand -> shape(2, 1) -> [[1.][0.]]

f) input_energy_t = shape(2, 4) * shape(2, 1) = shape(2, 4)
    [
      [ 40.  48.  56.  64.]
      [265. 318. 371. 424.]
    ]
    *
    [[1.][0.]]
    =
    [[40. 48. 56. 64.]
     [ 0.  0.  0.  0.]]

g) chain_energy =  chain_energy * K.expand_dims(K.expand_dims(m[:, 0] * m[:, 1]))

g1) chain_energy = shape(1, 4, 4) =
      [[[ 1.,  2.,  3.,  4.],
        [ 5.,  6.,  7.,  8.],
        [ 9., 10., 11., 12.],
        [13., 14., 15., 16.]]]

 g2!!!!!!!) m[:, 0] * m[:, 1] = (LINEAR CHAIN REALIZATION) = shape(2)*shape(2)= [1., 0.] * [1., 1.] = [1., 0.]

 g3)  K.expand_dims(K.expand_dims(m[:, 0] * m[:, 1])) = from shape(2) to shape(2,1,1) =  [[[1.]],[[0.]]]

 g) chain_energy = shape(1, 4, 4) * shape(2, 1, 1) = shape(2, 4, 4) =
    [[[ 1.  2.  3.  4.]
      [ 5.  6.  7.  8.]
      [ 9. 10. 11. 12.]
      [13. 14. 15. 16.]]

     [[ 0.  0.  0.  0.]
      [ 0.  0.  0.  0.]
      [ 0.  0.  0.  0.]
      [ 0.  0.  0.  0.]]]

 h) energy = chain_energy +  K.expand_dims(input_energy_t + prev_target_val, 2)
 h1) input_energy_t + prev_target_val = shape(2, 4) + shape(2, 4) = shape(2, 4)

    [[40. 48. 56. 64.]
      [ 0.  0.  0.  0.]]
    +
    [[0., 0., 0., 0.],
      [0., 0., 0., 0.]]
    =
    [[40. 48. 56. 64.]
     [ 0.  0.  0.  0.]]

  h2) K.expand_dims(input_energy_t + prev_target_val, 2)= from shape(2, 4) to shape (2, 4, 1) =   /axis = 2 = axis = -1/
      [[[40.]
        [48.]
        [56.]
        [64.]]

       [[ 0.]
        [ 0.]
        [ 0.]
        [ 0.]]]

 h) energy = shape(1, 4, 4) + shape(2, 4, 1) = shape(2, 4, 4)
    [[[41. 42. 43. 44.]
      [53. 54. 55. 56.]
      [65. 66. 67. 68.]
      [77. 78. 79. 80.]]

     [[ 0.  0.  0.  0.]
      [ 0.  0.  0.  0.]
      [ 0.  0.  0.  0.]
      [ 0.  0.  0.  0.]]]

  k) Find MIN_ENERGY =  min_energy = K.min(energy, 1) - to find min values in dim = 1
      shape=(2, 4) =

      [[41. 42. 43. 44.]
      [ 0.  0.  0.  0.]]

  l) ARGMIN_TABLE = K.cast(K.argmin(energy, 1), K.floatx())
